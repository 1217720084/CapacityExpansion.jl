#


# convert Euro to US dollars
# introduced because the clusters generated by the python script are in EUR for GER
function get_EUR_to_USD(region)
   if region =="GER"
     ret = 1.109729
   else
     ret =1
   end
   return ret
end


# plot cluster centroids for verification
 # \TODO add more comments or delete this function
function plot_clusters(k_plot,kshape_centroids,n_k,n_init)

  for k=1:n_k

    # plot centroids for verification
    if k==k_plot
      figure()
      for i=1:n_init
        plot(kshape_centroids[k][:,:,i]',color="0.75")
      end
      #data = Array(readtable(normpath(joinpath(pwd(),"..","..","data",data_folder,string(region_str, "Elec_Price_kmeans_","kshape","_","cluster", "_", k,".txt"))), separator = '\t', header = false))/get_EUR_to_USD(region);
      #plot(data',color="red")
      best = kshape_centroids[k][:,:,ind_best_dist[k]]
      plot(best',color="blue")
    end
  end
  if is_linux()
    plt.show()
  end
end # plot_clusters()


##
# z-normalize data with mean and sdv by hour
# data: input format: (1st dimension: 24 hours, 2nd dimension: # of days)
# hourly: true means univariate scaling: each hour is scaled seperately. False means one mean and standard deviation for the full data set.

function z_normalize(data;hourly=true)
  hourly_mean = zeros(size(data)[1])
  hourly_sdv = zeros(size(data)[1])
  data_norm = zeros(size(data))
  if hourly # alternatively, use mean_and_std() and zscore() from StatsBase.jl
    for i=1:size(data)[1]
      hourly_mean[i] = mean(data[i,:])
      hourly_sdv[i] = std(data[i,:])
      isnan(hourly_sdv[i]) &&  (hourly_sdv[i] =1)
      data_norm[i,:] = data[i,:] - hourly_mean[i]
      data_norm[i,:] = data_norm[i,:]/hourly_sdv[i]
    end
  else # hourly = false
    hourly_mean = mean(data)*ones(size(data)[1])
    hourly_sdv = std(data)*ones(size(data)[1])
    data_norm = (data-hourly_mean[1])/hourly_sdv[1]
  end
  return data_norm, hourly_mean, hourly_sdv
end # function z_normalize

##
# undo z-normalization data with mean and sdv by hour
# normalized data: input format: (1st dimension: 24 hours, 2nd dimension: # of days)
# hourly_mean ; 24 hour vector with hourly means
# hourly_sdv; 24 hour vector with hourly standard deviations

function undo_z_normalize(data_norm, hourly_mean, hourly_sdv)
  data = data_norm .* hourly_sdv + hourly_mean * ones(size(data_norm)[2])'
end

# calculates the minimum and maximum allowed indices for a lxl windowed matrix
# for the sakoe chiba band (see Sakoe Chiba, 1978).
# Input: radius r, such that |i(k)-j(k)| <= r
# length l: dimension 2 of the matrix

function sakoe_chiba_band(r::Int,l::Int)
  i2min = Int[]
  i2max = Int[]
  for i=1:l
    push!(i2min,max(1,i-r))
    push!(i2max,min(l,i+r))
  end
  return i2min, i2max
end
